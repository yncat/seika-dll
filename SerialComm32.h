
#if !defined(_SERIALCOMM32_H_INCLUDE_)
#define _SERIALCOMM32_H_INCLUDE_

#include "windows.h"
#include <string>
using namespace std;

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef SERIALCOMM_EXPORTS
#define SERIALCOMM_API __declspec(dllexport)
#else
#define SERIALCOMM_API __declspec(dllimport)
#pragma comment(lib, "SerialComm.lib")
#pragma message("Automatically linking with SerialComm.dll")
#endif

#define EVT_BREAK		CE_BREAK		// ハードウェアがブレーク条件を検出しました。 
#define EVT_DNS			CE_DNS			// Windows 95/98：パラレルデバイスが選択されていません。 
#define EVT_FRAME		CE_FRAME		// ハードウェアがフレーミングエラーを検出しました。 
#define EVT_IOE			CE_IOE			// デバイスとの通信中に I/O エラーが発生しました。 
#define EVT_MODE		CE_MODE			// 要求したモードがサポートされていません。または、ハンドルが無効です（ この値が指定された場合、このエラーコードのみが有効値となります）。 
#define EVT_OOP			CE_OOP			// Windows 95/98：パラレルデバイスが用紙切れになっています。 
#define EVT_OVERRUN		CE_OVERRUN		// 文字バッファがいっぱいになりました。次の文字は失われます。 
#define EVT_PTO			CE_PTO			// Windows 95/98：パラレルデバイスでタイムアウトになりました。 
#define EVT_RXOVER		CE_RXOVER		// 入力バッファのオーバーフローが発生しました。入力バッファに空きがないか、EOF の後に文字を受信しました。 
#define EVT_RXPARITY	CE_RXPARITY		// ハードウェアがパリティエラーを検出しました。 
#define EVT_TXFULL		CE_TXFULL		// アプリケーションが文字を送信しようとしましたが、出力バッファがいっぱいでした。 
#define	EVT_DONEINIT	0x00010000		// 通信モジュールのインスタンス初期化が完了しました。
#define EVT_DONEOPEN	0x00020000		// モジュールのオープンが完了しました。
#define EVT_RXCHAR		0x00100000		// データを受信しました。
#define EVT_ERROR		0x00200000		// 通信エラーが発生しました。

///////////////////////////////////////////////////////////////////////////////
// コールバック関数
///////////////////////////////////////////////////////////////////////////////
// 概要:
// 通信モジュールからのコールバック関数です。
// ください。イベント通知には以下のものがあります。
//		EVT_BREAK		ハードウェアがブレーク条件を検出しました。 
//		EVT_DNS			Windows 95/98：パラレルデバイスが選択されていません。 
//		EVT_FRAME		ハードウェアがフレーミングエラーを検出しました。 
//		EVT_IOE			デバイスとの通信中に I/O エラーが発生しました。 
//		EVT_MODE		要求したモードがサポートされていません。または、ハンド
//						ルが無効です（ この値が指定された場合、このエラーコー
//						ドのみが有効値となります）。 
//		EVT_OOP			Windows 95/98：パラレルデバイスが用紙切れになっています。 
//		EVT_OVERRUN		文字バッファがいっぱいになりました。次の文字は失われます。 
//		EVT_PTO			Windows 95/98：パラレルデバイスでタイムアウトになりました。 
//		EVT_RXOVER		入力バッファのオーバーフローが発生しました。入力バッファ
//						に空きがないか、EOF の後に文字を受信しました。 
//		EVT_RXPARITY	ハードウェアがパリティエラーを検出しました。 
//		EVT_TXFULL		アプリケーションが文字を送信しようとしましたが、出力バッ
//						ファがいっぱいでした。 
//		EVT_DONEINIT	通信モジュールのインスタンス初期化が完了しました。
//		EVT_DONEOPEN	モジュールのオープンが完了しました。
//		EVT_RXCHAR		データを受信しました。
//		EVT_ERROR		通信エラーが発生しました。
//
// パラメータ:
// UINT uEvent(O)：コールバック関数のイベント通知
// WPARAM wParam(O)：将来のために予約
// LPARAM lParam1(O)：通信ハンドル値
// LPARAM lParam2(O)：将来のために予約
// LPARAM lParam3(O)：将来のために予約
//
// 戻り値：
// 正常に終了した場合は、HANDLE 型のハンドル値を返します。
//
///////////////////////////////////////////////////////////////////////////////
typedef VOID (CALLBACK* LPFNCALLBACK)(UINT uEvent, WPARAM wParam, LPARAM lParam1, LPARAM lParam2, LPARAM lParam3);

//---------------------------------------------------------------------------
// The following is threads for the serial port watch.
//---------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
// モジュールの初期化
///////////////////////////////////////////////////////////////////////////////
// 概要:
// モジュールを初期化します。このモジュールを使用する前に最初に１回呼び出して
// ください。
//
// パラメータ:
// LPFNCALLBACK lpfnCallBackFn(I)：コールバック関数のアドレス
// LPVOID lpArgument(I)：NULL（将来のために予約）
//
// 戻り値：
// 正常に終了した場合は、HANDLE 型のハンドル値を返します。
//
///////////////////////////////////////////////////////////////////////////////
SERIALCOMM_API HANDLE WINAPI rs232c_CreateSerial(LPFNCALLBACK lpfnCallBackFn, LPVOID lpArgument);

///////////////////////////////////////////////////////////////////////////////
// モジュールの終了処理
///////////////////////////////////////////////////////////////////////////////
// 概要:
// モジュールをリソースを解放します。このモジュールの使用が終わったら１回呼び出
// してください。
//
// パラメータ:
// HANDLE hSerial(I)：通信ハンドル
//
// 戻り値：
// 正常に終了した場合は、TRUE を返します。
//
///////////////////////////////////////////////////////////////////////////////
SERIALCOMM_API BOOL WINAPI rs232c_DestroySerial(HANDLE hSerial);

///////////////////////////////////////////////////////////////////////////////
// シリアルモジュールのオープン処理
///////////////////////////////////////////////////////////////////////////////
// 概要:
// シリアルモジュールのオープン処理です。hSerial には通信ハンドルを指定します。
// nPort には通信デバイスのポート番号を指定してください。dcb にはシリアル通信
// デバイスの DCB 構造体を指定します。DCB 構造体の詳細については Windows API 
// のリファレンス（MSDN 等）を参照してください。送信および受信の両方の XON 文
// 字（XonChar）は 0x11。送信および受信の両方の XOFF 文字（XoffChar）は 0x13。
// また、ソフトウェアフロー制御の最大と最小文字数は 100 で設定されるので注意
// してください（変更不可）。
//
// パラメータ:
// HANDLE hSerial(I)：通信ハンドル
// int nPort(I)：ポート番号
// DCB dcb(I)：DCB 構造体
//
// 戻り値：
// 正常に終了した場合は、TRUE を返します。
//
///////////////////////////////////////////////////////////////////////////////
SERIALCOMM_API BOOL WINAPI rs232c_OpenSerial(HANDLE hSerial, int nPort, DCB dcb);

///////////////////////////////////////////////////////////////////////////////
// シリアルモジュールのクローズ処理
///////////////////////////////////////////////////////////////////////////////
// 概要:
// シリアルモジュールのクローズ処理です。hSerial には通信ハンドルを指定します。
//
// パラメータ:
// HANDLE hSerial(I)：通信ハンドル
//
// 戻り値：
// 正常に終了した場合は、TRUE を返します。
//
///////////////////////////////////////////////////////////////////////////////
SERIALCOMM_API BOOL WINAPI rs232c_CloseSerial(HANDLE hSerial);

///////////////////////////////////////////////////////////////////////////////
// データ送信
///////////////////////////////////////////////////////////////////////////////
// 概要:
// 通信ポート番号にデータを書き込みます。この関数は、非同期の操作を想定して設計
// されています。書き込みが完了すると、通信ポートに実際に書き込んだバイト数だけ
// 送信されますが、非同期処理操作のため、実際に送信されるとは限りません。
//
// パラメータ:
// HANDLE hSerial(I)：通信ハンドル
// LPCTSTR lpBuffer(I)：送信データバッファのポインタ
// DWORD dwBytesToWrite(I)：送信データバイト数
//
// 戻り値：
// 送信したバイト数。
//
///////////////////////////////////////////////////////////////////////////////
SERIALCOMM_API DWORD WINAPI rs232c_WriteCommBlock(HANDLE hSerial, LPCTSTR lpBuffer, DWORD dwBytesToWrite);

///////////////////////////////////////////////////////////////////////////////
// データ受信
///////////////////////////////////////////////////////////////////////////////
// 概要:
// 通信ポートからデータを読み取ります。この関数は、非同期の操作を想定して設計さ
// れています。そのため、指定された受信データバイト数と実際に受信されたバイト数
// が違う場合があります。
//
// パラメータ:
// HANDLE hSerial(I)：通信ハンドル
// LPTSTR lpBuffer(I)：受信データバッファのポインタ
// DWORD dwBytesToRead(I)：受信データバイト数
//
// 戻り値：
// 受信した文字数。
//
///////////////////////////////////////////////////////////////////////////////
SERIALCOMM_API DWORD WINAPI rs232c_ReadCommBlock(HANDLE hSerial, LPTSTR lpBuffer, DWORD dwBytesToRead);

///////////////////////////////////////////////////////////////////////////////
// ステータスの取得
///////////////////////////////////////////////////////////////////////////////
// 概要:
// シリアルモジュールのステータスを取得します。ステータスには送受信キューのデー
// タサイズ、モデムのステータスをそれぞれ設定します。
// lpModemStat にはモデム制御レジスタ値で、以下の値になります。
//		MS_CTS_ON：CTS（送信可）信号がオンです。 
//		MS_DSR_ON：DSR（データセットレディ）信号がオンです。 
//		MS_RING_ON：呼び出し信号がオンです。 
//		MS_RLSD_ON：RLSD（受信線信号検出）信号がオンです。 
//
// パラメータ:
// HANDLE hSerial(I)：通信ハンドル
// LPDWORD lpInQueSize(O)：受信キューデータサイズ
// LPDWORD lpOutQueSize(O)：送信キューデータサイズ
// LPDWORD lpModemStat(O)：モデムのステータス
//
// 戻り値：
// 正常に終了した場合は、TRUE を返します。
//
///////////////////////////////////////////////////////////////////////////////
SERIALCOMM_API BOOL WINAPI rs232c_GetCommStatus(HANDLE hSerial, LPDWORD lpInQueSize, LPDWORD lpOutQueSize, LPDWORD lpModemStat);

///////////////////////////////////////////////////////////////////////////////
// 送受信データの破棄
///////////////////////////////////////////////////////////////////////////////
// 概要:
// 出力バッファまたは入力バッファにあるすべての文字を破棄します。未処理の読み取
// り操作または書き込み操作を中止することもできます。
//
// パラメータ:
// HANDLE hSerial(I)：通信ハンドル
//
// 戻り値：
// 正常に終了した場合は、TRUE を返します。
//
///////////////////////////////////////////////////////////////////////////////
SERIALCOMM_API void WINAPI rs232c_FlushComm(HANDLE hSerial);

#endif // !defined(_SERIALCOMM32_H_INCLUDE_
